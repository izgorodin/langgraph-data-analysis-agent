# LGDA-014: Strict No-Fabrication On Error Paths

**Priority**: CRITICAL | **Type**: Reliability/UX | **Parallel**: Can run with LGDA-011, LGDA-012, LGDA-009

## Архитектурный контекст
Пользовательский опыт недопустим, если после ошибки система генерирует «мнимый/макетный» отчёт. Это подрывает доверие и искажает результаты. Требуется строгая политика: при сбое возвращать прозрачную ошибку и прекращать пайплайн, не производя «правдоподобных» артефактов.

## Цель задачи
Гарантировать, что при любой ошибке на стадиях validate_sql/execute_sql/analyze_df отчёт не генерируется. Вместо этого возвращается структурированная ошибка и рекомендации по восстановлению.

## Детальный анализ
- Наблюдение: после ошибки исполнения BQ был сгенерирован «классный ответ/отчёт», что недопустимо.
- Корень: узлы report/analyze_df не проверяют error-состояние строго, отсутствует «fail-fast» контракт.
- Риск: искажение данных и принятие неверных управленческих решений.

## Решение (Solution Architecture)
1. Контракт пайплайна
   - Ввести инвариант: если state.error != None → любой downstream-узел обязан завершить выполнение с контролируемой ошибкой без генерации контента.
2. Узлы графа
   - В `src/agent/graph.py` и узлах `report`, `analyze_df`: добавить жёсткую проверку error-флагов, ранний выход с `LGDAError` категории PERMANENT/USER_GUIDED.
3. Классификация и UX
   - В `src/error/classification.py`: метки стратегий USER_GUIDED для ошибок бизнес-уровня (валидация SQL, несоответствие типов), TRANSIENT для инфраструктурных.
   - В `src/error/recovery.py`: возвращать «what happened / what to do next» без фабрикации ответа.
4. Конфигурация
   - Переменная `LGDA_STRICT_NO_FAKE_REPORT=true` (по умолчанию true). Фича-флаг для обратной совместимости в тестах.

## Критерии приемки
- Любая ошибка на стадиях validate/execute/analyze приводит к отсутствию сгенерированного отчёта; возвращается структурированная ошибка.
- Интеграционные тесты проверяют, что при state.error отчёт не формируется.
- Логи содержат явный маркер fail-fast и категорию ошибки.

## Возможные сложности
- Ложные срабатывания fail-fast при мягких предупреждениях.
- Расхождение UX ожиданий: пользователи могут ждать «частичных» результатов.
- Совместимость с legacy-путями и тестовыми стабами.

## Integration Points
- LGDA-007 Unified Retry — согласование логики остановки vs повторных попыток.
- LGDA-009 Error Handling — категории ошибок и стратегии восстановления.
- LGDA-011 Observability — метрики/логи fail-fast, трассировка ветвления.

## ADR References
- ADR-003 Error Handling Strategy — политика классификации, fail-fast.
- ADR-005 Observability Strategy — требования к логам и трассировке.

## Безопасность
- Исключить утечку SQL/секретов/PII в сообщениях об ошибках (санитизация).
- Без включения сырых данных пользователя в отчёт при ошибке.
- Не понижать классификацию security-ошибок; они всегда PERMANENT и без ретрая.

## Производительность
- Проверка error-флага O(1), накладные расходы пренебрежимо малы.
- Логи/метрики — batched/async, не более 1% overhead.

## Зависимости
- LGDA-009 (error handling) — классификация и стратегии
- LGDA-011 (observability) — логгирование маркеров fail-fast

## Оценка трудозатрат
0.5–1 день | Изменения: 2–3 файла | Тесты: 3–4
